### Testing the backend

- We will now start writing tests for the backend. 
- Since the backend does not contain any complicated logic, it doesn't make sense to write unit tests for it. 
- The only potential thing we could unit test is the toJSON method that is used for formatting notes.

- In some situations, it can be beneficial to implement some of the backend tests by mocking the database instead of using a real database. 
    - One library that could be used for this is mongo-mock.

- Since our application's backend is still relatively simple, we will make the decision to test the entire application through its REST API, so that the database is also included. 
- This kind of testing where multiple components of the system are being tested as a group, is called integration testing.

### Test environment

- In one of the previous chapters of the course material, we mentioned that when your backend server is running in Heroku, it is in production mode.

- The convention in Node is to define the execution mode of the application with the NODE_ENV environment variable. In our current application, we only load the environment variables defined in the .env file if the application is not in production mode.

- It is common practice to define separate modes for development and testing.

- Next, let's change the scripts in our package.json so that when tests are run, NODE_ENV gets the value test:

```javascript

{
  // ...
  "scripts": {
    "start": "NODE_ENV=production node index.js",    "dev": "NODE_ENV=development nodemon index.js",    "build:ui": "rm -rf build && cd ../../../2/luento/notes && npm run build && cp -r build ../../../3/luento/notes-backend",
    "deploy": "git push heroku master",
    "deploy:full": "npm run build:ui && git add . && git commit -m uibuild && git push && npm run deploy",
    "logs:prod": "heroku logs --tail",
    "lint": "eslint .",
    "test": "NODE_ENV=test jest --verbose --runInBand"  },
  // ...
}
```

- We also added the `runInBand` option to the npm script that executes the tests. 
- This option will prevent Jest from running tests in parallel; we will discuss its significance once our tests start using the database.

- We specified the mode of the application to be development in the `npm run dev` script that uses nodemon. 
- We also specified that the default npm st`art command will define the mode as production.

- There is a slight issue in the way that we have specified the mode of the application in our scripts: it will not work on Windows. 
- We can correct this by installing the `cross-env` package with the command:

`npm install cross-env`

- We can then achieve cross-platform compatibility by using the cross-env library in our npm scripts defined in package.json:

```javascript

{
  // ...
  "scripts": {
    "start": "cross-env NODE_ENV=production node index.js",
    "dev": "cross-env NODE_ENV=development nodemon index.js",
    // ...
    "test": "cross-env NODE_ENV=test jest --verbose --runInBand",
  },
  // ...
}
```

- Now we can modify the way that our application runs in different modes. As an example of this, we could define the application to use a separate test database when it is running tests.

- We can create our separate test database in Mongo DB Atlas. This is not an optimal solution in situations where there are many people developing the same application. Test execution in particular typically requires that a single database instance is not used by tests that are running concurrently.

- It would be better to run our tests using a database that is installed and running in the developer's local machine. The optimal solution would be to have every test execution use its own separate database. This is "relatively simple" to achieve by running Mongo in-memory or by using Docker containers. We will not complicate things and will instead continue to use the MongoDB Atlas database.

- Let's make some changes to the module that defines the application's configuration:

```javascript

require('dotenv').config()

let PORT = process.env.PORT
let MONGODB_URI = process.env.MONGODB_URI

if (process.env.NODE_ENV === 'test') {  MONGODB_URI = process.env.TEST_MONGODB_URI}
module.exports = {
  MONGODB_URI,
  PORT
}
```

- The .env file has separate variables for the database addresses of the development and test databases:

```javascript
MONGODB_URI=mongodb+srv://fullstack:secred@cluster0-ostce.mongodb.net/note-app?retryWrites=true
PORT=3001

TEST_MONGODB_URI=mongodb+srv://fullstack:secret@cluster0-ostce.mongodb.net/note-app-test?retryWrites=true
```

- The config module that we have implemented slightly resembles the node-config package. Writing our own implementation is justified since our application is simple, and also because it teaches us valuable lessons.

- These are the only changes we need to make to our application's code.


### supertest

- Let's use the supertest package to help us write our tests for testing the API.

- We will install the package as a development dependency:

`npm install --save-dev supertest`

- Let's write our first test in the tests/note_api.test.js file:

```javascript

const mongoose = require('mongoose')
const supertest = require('supertest')
const app = require('../app')

const api = supertest(app)

test('notes are returned as json', async () => {
  await api
    .get('/api/notes')
    .expect(200)
    .expect('Content-Type', /application\/json/)
})

afterAll(() => {
  mongoose.connection.close()
})
```

- The test imports the Express application from the app.js module and wraps it with the supertest function into a so-called superagent object. This object is assigned to the api variable and tests can use it for making HTTP requests to the backend.

- Our test makes an HTTP GET request to the api/notes url and verifies that the request is responded to with the status code 200. The test also verifies that the Content-Type header is set to application/json, indicating that the data is in the desired format.

- The test contains some details that we will explore a bit later on. The arrow function that defines the test is preceded by the async keyword and the method call for the api object is preceded by the await keyword. We will write a few tests and then take a closer look at this async/await magic. Do not concern yourself with them for now, just be assured that the example tests work correctly. The async/await syntax is related to the fact that making a request to the API is an asynchronous operation. The Async/await syntax can be used for writing asynchronous code with the appearance of synchronous code.

- Once all the tests (there is currently only one) have finished running we have to close the database connection used by Mongoose. This can be easily achieved with the afterAll method:

```javascript

afterAll(() => {
  mongoose.connection.close()
})
```

- When running your tests you may run across the following console warning:

`Jest did not exit one second after the test run has completed`

- If this occurs, let's follow the instructions and add a jest.config.js file at the root of the project with the following content:

```javascript

module.exports = {
  testEnvironment: 'node'
}
```

- One tiny but important detail: at the beginning of this part we extracted the Express application into the app.js file, and the role of the index.js file was changed to launch the application at the specified port with Node's built-in http object:

```javascript

const app = require('./app') // the actual Express app
const http = require('http')
const config = require('./utils/config')
const logger = require('./utils/logger')

const server = http.createServer(app)

server.listen(config.PORT, () => {
  logger.info(`Server running on port ${config.PORT}`)
})
```

- The tests only use the express application defined in the app.js file:

```javascript

const mongoose = require('mongoose')
const supertest = require('supertest')
const app = require('../app')
const api = supertest(app)

// ...
```

- The documentation for supertest says the following:
*if the server is not already listening for connections then it is bound to an ephemeral port for you so there is no need to keep track of ports.*

- In other words, supertest takes care that the application being tested is started at the port that it uses internally.

- Let's write a few more tests:

```javascript

test('there are two notes', async () => {
  const response = await api.get('/api/notes')

  expect(response.body).toHaveLength(2)
})

test('the first note is about HTTP methods', async () => {
  const response = await api.get('/api/notes')

  expect(response.body[0].content).toBe('HTML is easy')
})
```

- Both tests store the response of the request to the response variable, and unlike the previous test that used the methods provided by supertest for verifying the status code and headers, this time we are inspecting the response data stored in response.body property. Our tests verify the format and content of the response data with the expect method of Jest.

- The benefit of using the async/await syntax is starting to become evident. Normally we would have to use callback functions to access the data returned by promises, but with the new syntax things are a lot more comfortable:

```javascript

const res = await api.get('/api/notes')

// execution gets here only after the HTTP request is complete
// the result of HTTP request is saved in variable res
expect(res.body).toHaveLength(2)
```

- The middleware that outputs information about the HTTP requests is obstructing the test execution output. Let us modify the logger so that it does not print to console in test mode:

```
const info = (...params) => {
  if (process.env.NODE_ENV !== 'test') {     console.log(...params)  }}

const error = (...params) => {
  console.error(...params)
}

module.exports = {
  info, error
}
```

### Initializing the  database before tests

- Testing appears to be easy and our tests are currently passing. However, our tests are bad as they are dependent on the state of the database (that happens to be correct in my test database). In order to make our tests more robust, we have to reset the database and generate the needed test data in a controlled manner before we run the tests.

- Our tests are already using the `afterAll` function of Jest to close the connection to the database after the tests are finished executing. Jest offers many other functions that can be used for executing operations once before any test is run, or every time before a test is run.

- Let's initialize the database before every test with the `beforeEach` function:

```javascript
const mongoose = require('mongoose')
const supertest = require('supertest')
const app = require('../app')
const api = supertest(app)
const Note = require('../models/note')

const initialNotes = [
  {
    content: 'HTML is easy',
    important: false,
  },
  {
    content: 'Browser can execute only Javascript',
    important: true,
  },
]

beforeEach(async () => {
  await Note.deleteMany({})

  let noteObject = new Note(initialNotes[0])
  await noteObject.save()

  noteObject = new Note(initialNotes[1])
  await noteObject.save()
})
```

- The database is cleared out at the beginning, and after that we save the two notes stored in the initialNotes array to the database. Doing this, we ensure that the database is in the same state before every test is run.

- Let's also make the following changes to the last two tests:

```javascript

test('all notes are returned', async () => {
  const response = await api.get('/api/notes')

  expect(response.body).toHaveLength(initialNotes.length)
})

test('a specific note is within the returned notes', async () => {
  const response = await api.get('/api/notes')

  const contents = response.body.map(r => r.content)

  expect(contents).toContain(
    'Browser can execute only Javascript'  
  )
})
```

- Pay special attention to the expect in the latter test. 
- The `response.body.map(r => r.content)` command is used to create an array containing the content of every note returned by the API. 
- The toContain method is used for checking that the note given to it as a parameter is in the list of notes returned by the API.

### Running tests one by one

- The `npm test` command executes all of the tests of the application. 
- When we are writing tests, it is usually wise to only execute one or two tests. 
- Jest offers a few different ways of accomplishing this, one of which is the only method. 
  - If tests are written across many files, this method is not great.

- A better option is to specify the tests that need to be run as parameter of the `npm test` command.

- The following command only runs the tests found in the tests/note_api.test.js file:

`npm test -- tests/note_api.test.js`